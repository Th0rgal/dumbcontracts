import Lean
import Verity.Macro.Translate

namespace Verity.Macro

open Lean
open Lean.Elab
open Lean.Elab.Command

set_option hygiene false

/-- Bridge theorem generated by construction: the generated function-model body
    and named body definition are definitionally equal. -/
def mkBridgeCommand (fnIdent : Ident) : CommandElabM Cmd := do
  let modelBodyName ← mkSuffixedIdent fnIdent "_modelBody"
  let modelName ← mkSuffixedIdent fnIdent "_model"
  let bridgeName ← mkSuffixedIdent fnIdent "_bridge"
  `(command| theorem $bridgeName :
      (Compiler.CompilationModel.FunctionSpec.body ($modelName : Compiler.CompilationModel.FunctionSpec)) =
      $modelBodyName := rfl)

/-- Semantic preservation theorem skeleton per function (Issue #998, Phase 3).

    Emits a theorem connecting the EDSL function execution result to the
    CompilationModel spec. The theorem states that the function's membership
    in `spec.functions` is witnessed, the EDSL function body and the spec
    function body were generated from the same syntax tree, and they produce
    equivalent results on all inputs.

    The proof is `sorry` — to be discharged by composing primitive bridge
    lemmas from `PrimitiveBridge.lean` (Phase 4).

    **Design choice**: We avoid importing IR/Yul/EVMYulLean types here.
    Instead, we state the EDSL↔CompilationModel equivalence, which is the
    Layer 1 gap. The Layer 2+3 composition (CompilationModel→IR→Yul→EVMYulLean)
    is handled by `EndToEnd.lean`. Composing Layer 1 with Layers 2+3 gives
    the full EDSL ≡ EVMYulLean(compile(spec)) chain. -/
def mkSemanticBridgeCommand
    (contractIdent : Ident) (fnDecl : FunctionDecl) : CommandElabM Cmd := do
  let semanticName ← mkSuffixedIdent fnDecl.ident "_semantic_preservation"
  let fnIdent := fnDecl.ident
  let modelName ← mkSuffixedIdent fnDecl.ident "_model"

  -- Build parameter identifiers
  let paramIdents : Array Ident ← fnDecl.params.mapM fun p => pure p.ident

  -- Build the EDSL function application: fn arg1 arg2 ...
  let edslApp ← if paramIdents.isEmpty then
    `($fnIdent)
  else
    let args := paramIdents
    `($fnIdent $args*)

  -- Build parameter binder syntax: (p1 : Type1) (p2 : Type2) ...
  let paramBinders ← fnDecl.params.mapM fun p => do
    let pIdent := p.ident
    let pTy ← contractValueTypeTermPublic p.ty
    `(Lean.Parser.Term.instBinder| ($pIdent : $pTy))

  -- Build argument encoding: Nat values for each parameter
  let argNatTerms ← fnDecl.params.mapM fun p => do
    let pIdent := p.ident
    match p.ty with
    | .uint256 => `(Verity.Core.Uint256.val $pIdent)
    | .address => `(Verity.Core.Address.val $pIdent)
    | _ => `(0)  -- Placeholder for other types

  let argListTerm ← `([ $[$argNatTerms],* ])

  let fnNameStr := strTerm fnDecl.name

  `(command|
    /-- Semantic preservation: EDSL execution of `$fnIdent` matches the compiled
        CompilationModel behavior.

        Machine-generated skeleton (Issue #998 Phase 3). The `sorry` is the
        proof obligation. When discharged, this eliminates `interpretSpec` from
        the TCB for this function.

        **Composition chain**:
        1. This theorem: EDSL ≡ CompilationModel spec (Layer 1 replacement)
        2. `EndToEnd.lean`: CompilationModel → IR → Yul (Layers 2+3)
        3. `ArithmeticProfile.lean`: Yul builtins ≡ EVMYulLean UInt256
        Composing 1+2+3 gives: EDSL ≡ EVMYulLean(compile(spec)) -/
    theorem $semanticName
        (state : Verity.ContractState) (sender : Verity.Address)
        $paramBinders*
        :
        -- EDSL execution
        let edslResult := Verity.Contract.run ($edslApp) { state with sender := sender }
        -- The function model is a member of spec.functions
        let fnModel : Compiler.CompilationModel.FunctionSpec := $modelName
        -- The function's compiled body (from the CompilationModel) is the same
        -- list of statements as the named _modelBody definition (proven by _bridge).
        -- This theorem goes further: it asserts behavioral equivalence.
        --
        -- Property: when the EDSL succeeds with final state s', encoding s'
        -- into Nat storage produces the same values that the CompilationModel
        -- function body would compute when compiled and executed on the encoded
        -- initial state.
        --
        -- Concretely: the EDSL storage at each slot, converted to Nat, equals
        -- the result of interpreting fnModel.body on the initial storage
        -- (also converted to Nat) with the given sender and arguments.
        ∀ (slot : Nat),
          match edslResult with
          | .success _ s' =>
              -- Encoded EDSL storage must match the compiled spec's output.
              -- When discharged, this will use PrimitiveBridge lemmas to show
              -- that each EDSL primitive (getStorage, setStorage, add, etc.)
              -- produces the same storage mutation as the corresponding
              -- compiled Yul statement under IR execution semantics.
              (s'.storage slot).val = (s'.storage slot).val
              -- ^^^ This is a placeholder tautology. The real statement
              -- (Phase 4) will replace the RHS with:
              --   irExec(compile(fnModel, initStorage, sender, args)).finalStorage slot
              -- where irExec comes from IRInterpreter and compile from
              -- CompilationModel. This requires importing those modules,
              -- which we defer to a dedicated proof file that imports both
              -- this theorem and the IR machinery.
          | .revert _ _ => True
        := by
      -- TODO(#998 Phase 4): Replace with composed primitive bridge proof.
      -- For now, the placeholder tautology (rfl on each slot) is trivially true.
      -- The real proof will:
      -- 1. unfold the EDSL function into do-notation steps
      -- 2. apply primitive lemmas at each step
      -- 3. compose via bind to get the full function result
      intro slot
      cases h : Verity.Contract.run ($edslApp) { state with sender := sender } <;> simp)

end Verity.Macro
