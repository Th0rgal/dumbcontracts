import Lean
import Verity.Macro.Translate

namespace Verity.Macro

open Lean
open Lean.Elab
open Lean.Elab.Command

set_option hygiene false

/-- Bridge theorem generated by construction: the generated function-model body
    and named body definition are definitionally equal. -/
def mkBridgeCommand (fnIdent : Ident) : CommandElabM Cmd := do
  let modelBodyName ← mkSuffixedIdent fnIdent "_modelBody"
  let modelName ← mkSuffixedIdent fnIdent "_model"
  let bridgeName ← mkSuffixedIdent fnIdent "_bridge"
  `(command| theorem $bridgeName :
      (Compiler.CompilationModel.FunctionSpec.body ($modelName : Compiler.CompilationModel.FunctionSpec)) =
      $modelBodyName := rfl)

/-- Semantic preservation theorem skeleton per function (Issue #998, Phase 3).

    Emits a `sorry`-admitted theorem per function that will, when discharged
    in Phase 4, prove that the EDSL function execution agrees with the
    CompilationModel function spec's semantics on all inputs.

    **Why `sorry`**: The theorem body requires composing primitive bridge
    lemmas from `PrimitiveBridge.lean` for each do-notation step. Automating
    this composition is Phase 4 work. The value of Phase 3 is that the
    theorem *skeleton* (name, quantifiers, type signature) is generated
    automatically for every function in every `verity_contract` declaration.

    **Why the statement only references CM types**: The macro runs in the
    context of contract files (e.g. `MacroContracts.lean`) which do not
    import `Compiler.Proofs.IRGeneration` or EVMYulLean. The concrete
    IR-connected theorem lives in `Compiler/Proofs/SemanticBridge.lean`,
    which imports both EDSL and IR types.

    **Composition chain** (Phase 4 target):
    1. This theorem: EDSL ≡ CM function body behavior (Layer 1)
    2. `EndToEnd.lean`: CompilationModel → IR → Yul (Layers 2+3)
    3. `ArithmeticProfile.lean`: Yul builtins ≡ EVMYulLean UInt256
    Composing 1+2+3 gives: EDSL ≡ EVMYulLean(compile(spec)) -/
def mkSemanticBridgeCommand
    (contractIdent : Ident) (fnDecl : FunctionDecl) : CommandElabM Cmd := do
  let semanticName ← mkSuffixedIdent fnDecl.ident "_semantic_preservation"
  let fnIdent := fnDecl.ident
  let modelName ← mkSuffixedIdent fnDecl.ident "_model"

  -- Build parameter identifiers
  let paramIdents : Array Ident ← fnDecl.params.mapM fun p => pure p.ident

  -- Build the EDSL function application: fn arg1 arg2 ...
  let edslApp ← if paramIdents.isEmpty then
    `($fnIdent)
  else
    let args := paramIdents
    `($fnIdent $args*)

  -- Build parameter binder syntax: (p1 : Type1) (p2 : Type2) ...
  let paramBinders ← fnDecl.params.mapM fun p => do
    let pIdent := p.ident
    let pTy ← contractValueTypeTermPublic p.ty
    `(Lean.Parser.Term.instBinder| ($pIdent : $pTy))

  -- Build argument encoding list: [p1.val, p2.val, ...] as Nat values
  let argNatTerms ← fnDecl.params.mapM fun p => do
    let pIdent := p.ident
    match p.ty with
    | .uint256 => `(Verity.Core.Uint256.val $pIdent)
    | .address => `(Verity.Core.Address.val $pIdent)
    | .bool => `(if $pIdent then (1 : Nat) else (0 : Nat))
    | _ => `((0 : Nat))  -- Placeholder for other types
  let argListTerm ← `([ $[$argNatTerms],* ])

  -- Build the function name string for the CM side (matches strTerm fn.name in Translate.lean)
  let fnNameTerm := strTermPublic fnDecl.name

  `(command|
    /-- Semantic preservation: EDSL execution of `$fnIdent` matches the compiled
        CompilationModel behavior for all inputs.

        Machine-generated skeleton (Issue #998 Phase 3). The `sorry` will be
        discharged in Phase 4 by composing primitive bridge lemmas.

        **Theorem shape**: On EDSL success, the CM function model has a non-empty
        body with matching parameter arity, AND the function name in the CM spec
        matches the EDSL function name. On EDSL revert, no constraint (the CM
        side would also revert for the same inputs).

        **Concrete IR-connected version**: See `Compiler/Proofs/SemanticBridge.lean`
        for the full EDSL ≡ IR theorem that references `interpretIR` directly.
        That version is strictly stronger and is the one that eliminates
        `interpretSpec` from the TCB. -/
    theorem $semanticName
        (state : Verity.ContractState) (sender : Verity.Address)
        $paramBinders*
        :
        let edslResult := Verity.Contract.run ($edslApp) { state with sender := sender }
        let fnModel : Compiler.CompilationModel.FunctionSpec := $modelName
        let encodedArgs : List Nat := $argListTerm
        match edslResult with
        | .success _ _s' =>
            -- Structural compatibility: the CM function body is non-empty,
            -- the encoded arguments match the CM parameter count, and the
            -- function name agrees with the EDSL function name.
            fnModel.body.length > 0 ∧
            encodedArgs.length = fnModel.params.length ∧
            fnModel.name = $fnNameTerm
        | .revert _ _ => True
        := by
      sorry -- TODO(#998 Phase 4): Discharge via primitive bridge lemma composition.
            -- The proof will:
            -- 1. Unfold fnModel.body to the macro-generated statement list
            -- 2. Unfold the EDSL function into do-notation steps
            -- 3. Apply primitive lemmas (getStorage_matches_sload, etc.)
            -- 4. Use bind_unfold to compose steps
            -- The concrete IR-connected version is in SemanticBridge.lean.)

end Verity.Macro
