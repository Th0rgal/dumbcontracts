import Lean
import Verity.Macro.Translate
import Verity.Proofs.Stdlib.SpecInterpreter

namespace Verity.Macro

open Lean
open Lean.Elab
open Lean.Elab.Command

set_option hygiene false

/-- Bridge theorem generated by construction: the generated function-model body
    and named body definition are definitionally equal. -/
def mkBridgeCommand (fnIdent : Ident) : CommandElabM Cmd := do
  let modelBodyName ← mkSuffixedIdent fnIdent "_modelBody"
  let modelName ← mkSuffixedIdent fnIdent "_model"
  let bridgeName ← mkSuffixedIdent fnIdent "_bridge"
  `(command| theorem $bridgeName :
      (Compiler.CompilationModel.FunctionSpec.body ($modelName : Compiler.CompilationModel.FunctionSpec)) =
      $modelBodyName := rfl)

/-- Build a SpecStorage term from storage field declarations.

    For each field, generates the appropriate slot entry:
    - Scalar Uint256 → `(slotNum, (state.storage slotNum).val)`
    - Scalar Address → `(slotNum, (state.storageAddr slotNum).val)`
    - Mappings are not included in the slot list (they use separate SpecStorage fields)

    The generated term looks like:
    ```
    { slots := [(0, (state.storage 0).val), (1, (state.storageAddr 1).val), ...]
      mappings := [], mappings2 := [], events := [] }
    ```

    Note: `state` must be in scope as a `Verity.ContractState` when this term
    is elaborated. -/
private def mkSpecStorageTerm (fields : Array StorageFieldDecl) : CommandElabM Term := do
  let mut slotTerms : Array Term := #[]
  for field in fields do
    let slotNumTerm := natTermPublic field.slotNum
    match field.ty with
    | .scalar .uint256 =>
      slotTerms := slotTerms.push (← `(($slotNumTerm, (state.storage $slotNumTerm).val)))
    | .scalar .address =>
      slotTerms := slotTerms.push (← `(($slotNumTerm, (state.storageAddr $slotNumTerm).val)))
    | .scalar .bytes32 =>
      slotTerms := slotTerms.push (← `(($slotNumTerm, (state.storage $slotNumTerm).val)))
    | _ =>
      -- Mappings and other complex types: skip for slot list
      -- (they use SpecStorage.mappings/mappings2 which we leave empty for now)
      slotTerms := slotTerms  -- explicit no-op to avoid monad confusion
  `({ slots := [ $[$slotTerms],* ]
      mappings := []
      mappings2 := []
      events := [] : Verity.Proofs.Stdlib.SpecInterpreter.SpecStorage })

/-- Build per-slot equality assertions for the success case.

    For each declared storage field, generates an equality between the EDSL
    final state and the interpretSpec final storage:
    - Uint256 at slot n: `(s'.storage n).val = specResult.finalStorage.getSlot n`
    - Address at slot n: `(s'.storageAddr n).val = specResult.finalStorage.getSlot n`

    Returns the conjunction: `specResult.success = true ∧ eq0 ∧ eq1 ∧ ...`
    Note: `s'` and `specResult` must be in scope when the result is elaborated. -/
private def mkSuccessAssertion (fields : Array StorageFieldDecl) : CommandElabM Term := do
  let mut slotEqTerms : Array Term := #[]
  for field in fields do
    let slotNumTerm := natTermPublic field.slotNum
    match field.ty with
    | .scalar .uint256 =>
      slotEqTerms := slotEqTerms.push
        (← `((s'.storage $slotNumTerm).val =
             Verity.Proofs.Stdlib.SpecInterpreter.SpecStorage.getSlot
               specResult.finalStorage $slotNumTerm))
    | .scalar .address =>
      slotEqTerms := slotEqTerms.push
        (← `((s'.storageAddr $slotNumTerm).val =
             Verity.Proofs.Stdlib.SpecInterpreter.SpecStorage.getSlot
               specResult.finalStorage $slotNumTerm))
    | .scalar .bytes32 =>
      slotEqTerms := slotEqTerms.push
        (← `((s'.storage $slotNumTerm).val =
             Verity.Proofs.Stdlib.SpecInterpreter.SpecStorage.getSlot
               specResult.finalStorage $slotNumTerm))
    | _ =>
      slotEqTerms := slotEqTerms  -- no-op for mappings
  -- Build the conjunction: success = true ∧ slot0_eq ∧ slot1_eq ∧ ...
  let mut conj ← `(specResult.success = true)
  for eq in slotEqTerms do
    conj ← `($conj ∧ $eq)
  return conj

/-- Semantic preservation theorem per function (Issue #998, Phase 3).

    Emits a `sorry`-admitted theorem per function proving that the EDSL
    function execution agrees with `interpretSpec` applied to the contract's
    `CompilationModel` spec on all inputs.

    **What it proves**: For any state, sender, and function parameters:
    - If the EDSL succeeds with final state `s'`, then `interpretSpec` also
      succeeds and its final storage agrees on all declared slots.
    - If the EDSL reverts, then `interpretSpec` also reports failure.

    **Why `sorry`**: Discharging requires composing primitive bridge lemmas
    from `PrimitiveBridge.lean` for each do-notation step. Automating this
    composition is Phase 4 work.

    **Why `interpretSpec`**: The macro runs in contract-file context (e.g.
    `MacroContracts.lean`) which does not import IR types or EVMYulLean.
    The statement uses `interpretSpec` as the CM reference semantics.
    Combined with Layers 2+3 (`EndToEnd.lean`), discharging these theorems
    eliminates `interpretSpec` from the TCB entirely.

    **Composition chain** (Phase 4 target):
    1. This theorem: EDSL ≡ interpretSpec(CM spec) (Layer 1)
    2. `EndToEnd.lean`: CompilationModel → IR → Yul (Layers 2+3)
    3. `ArithmeticProfile.lean`: Yul builtins ≡ EVMYulLean UInt256
    Composing 1+2+3 gives: EDSL ≡ EVMYulLean(compile(spec)) -/
def mkSemanticBridgeCommand
    (contractIdent : Ident) (fields : Array StorageFieldDecl) (fnDecl : FunctionDecl)
    : CommandElabM Cmd := do
  let semanticName ← mkSuffixedIdent fnDecl.ident "_semantic_preservation"
  let fnIdent := fnDecl.ident

  -- Build parameter identifiers
  let paramIdents : Array Ident := fnDecl.params.map fun p => p.ident

  -- Build the EDSL function application: fn arg1 arg2 ...
  let edslApp ← if paramIdents.isEmpty then
    `($fnIdent)
  else
    let args := paramIdents
    `($fnIdent $args*)

  -- Build argument encoding list: [p1.val, p2.val, ...] as Nat values
  let argNatTerms ← fnDecl.params.mapM fun p => do
    let pIdent := p.ident
    match p.ty with
    | .uint256 => `(Verity.Core.Uint256.val $pIdent)
    | .address => `(Verity.Core.Address.val $pIdent)
    | .bool => `(if $pIdent then (1 : Nat) else (0 : Nat))
    | _ => `((0 : Nat))  -- Placeholder for other types
  let argListTerm ← `([ $[$argNatTerms],* ])

  -- Build the function name string
  let fnNameTerm := strTermPublic fnDecl.name

  -- Build the SpecStorage conversion from EDSL ContractState
  let specStorageTerm ← mkSpecStorageTerm fields

  -- Build success and revert assertions
  let successTerm ← mkSuccessAssertion fields

  -- Build the core proposition (the theorem type)
  let mut body ← `(
    let edslResult := Verity.Contract.run ($edslApp) { state with sender := sender }
    let specStorage : Verity.Proofs.Stdlib.SpecInterpreter.SpecStorage := $specStorageTerm
    let specResult := Verity.Proofs.Stdlib.SpecInterpreter.interpretSpec
        spec specStorage
        { sender := sender
          functionName := $fnNameTerm
          args := $argListTerm
          : Compiler.DiffTestTypes.Transaction }
    match edslResult with
    | .success _ s' => $successTerm
    | .revert _ _ => specResult.success = false)

  -- Wrap function-specific parameters as ∀ binders (reverse so first param is outermost).
  -- We use ∀ instead of theorem-level binders because Lean 4 quotation syntax
  -- doesn't support splicing variable-length bracketedBinder arrays into `theorem`.
  for p in fnDecl.params.reverse do
    let pIdent := p.ident
    let pTy ← contractValueTypeTermPublic p.ty
    body ← `(∀ ($pIdent : $pTy), $body)

  `(command|
    /-- Semantic preservation: EDSL execution of `$fnIdent` matches
        `interpretSpec` applied to the contract's CompilationModel spec.

        Machine-generated (Issue #998 Phase 3). The `sorry` will be
        discharged in Phase 4 by composing primitive bridge lemmas.

        On EDSL success: `interpretSpec` succeeds and all declared storage
        slots agree between the EDSL final state and the spec's final storage.
        On EDSL revert: `interpretSpec` also reports failure. -/
    theorem $semanticName
        (state : Verity.ContractState) (sender : Verity.Address)
        : $body := by sorry)

end Verity.Macro
