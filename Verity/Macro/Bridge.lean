import Lean
import Verity.Macro.Translate

namespace Verity.Macro

open Lean
open Lean.Elab
open Lean.Elab.Command

set_option hygiene false

/-- Bridge theorem generated by construction: the generated function-model body
    and named body definition are definitionally equal. -/
def mkBridgeCommand (fnIdent : Ident) : CommandElabM Cmd := do
  let modelBodyName ← mkSuffixedIdent fnIdent "_modelBody"
  let modelName ← mkSuffixedIdent fnIdent "_model"
  let bridgeName ← mkSuffixedIdent fnIdent "_bridge"
  `(command| theorem $bridgeName :
      (Compiler.CompilationModel.FunctionSpec.body ($modelName : Compiler.CompilationModel.FunctionSpec)) =
      $modelBodyName := rfl)

/-- Semantic preservation theorem skeleton per function (Issue #998, Phase 3).

    Emits a `sorry`-admitted theorem per function that will, when discharged
    in Phase 4, prove that the EDSL function execution agrees with the
    CompilationModel function spec's semantics on all inputs.

    **Why `sorry`**: The theorem body requires composing primitive bridge
    lemmas from `PrimitiveBridge.lean` for each do-notation step. Automating
    this composition is Phase 4 work. The value of Phase 3 is that the
    theorem *skeleton* (name, quantifiers, type signature) is generated
    automatically for every function in every `verity_contract` declaration.

    **Why the statement only references CM types**: The macro runs in the
    context of contract files (e.g. `MacroContracts.lean`) which do not
    import `Compiler.Proofs.IRGeneration` or EVMYulLean. The concrete
    IR-connected theorem lives in `Compiler/Proofs/SemanticBridge.lean`,
    which imports both EDSL and IR types.

    **Composition chain** (Phase 4 target):
    1. This theorem: EDSL ≡ CM function body behavior (Layer 1)
    2. `EndToEnd.lean`: CompilationModel → IR → Yul (Layers 2+3)
    3. `ArithmeticProfile.lean`: Yul builtins ≡ EVMYulLean UInt256
    Composing 1+2+3 gives: EDSL ≡ EVMYulLean(compile(spec)) -/
def mkSemanticBridgeCommand
    (contractIdent : Ident) (fnDecl : FunctionDecl) : CommandElabM Cmd := do
  let semanticName ← mkSuffixedIdent fnDecl.ident "_semantic_preservation"
  let fnIdent := fnDecl.ident
  let modelName ← mkSuffixedIdent fnDecl.ident "_model"

  -- Build parameter identifiers
  let paramIdents : Array Ident ← fnDecl.params.mapM fun p => pure p.ident

  -- Build the EDSL function application: fn arg1 arg2 ...
  let edslApp ← if paramIdents.isEmpty then
    `($fnIdent)
  else
    let args := paramIdents
    `($fnIdent $args*)

  -- Build parameter binder syntax: (p1 : Type1) (p2 : Type2) ...
  let paramBinders ← fnDecl.params.mapM fun p => do
    let pIdent := p.ident
    let pTy ← contractValueTypeTermPublic p.ty
    `(Lean.Parser.Term.instBinder| ($pIdent : $pTy))

  -- Build argument encoding list: [p1.val, p2.val, ...] as Nat values
  let argNatTerms ← fnDecl.params.mapM fun p => do
    let pIdent := p.ident
    match p.ty with
    | .uint256 => `(Verity.Core.Uint256.val $pIdent)
    | .address => `(Verity.Core.Address.val $pIdent)
    | .bool => `(if $pIdent then (1 : Nat) else (0 : Nat))
    | _ => `((0 : Nat))  -- Placeholder for other types
  let argListTerm ← `([ $[$argNatTerms],* ])

  `(command|
    /-- Semantic preservation: EDSL execution of `$fnIdent` matches the compiled
        CompilationModel behavior for all inputs.

        Machine-generated skeleton (Issue #998 Phase 3). The `sorry` will be
        discharged in Phase 4 by composing primitive bridge lemmas. -/
    theorem $semanticName
        (state : Verity.ContractState) (sender : Verity.Address)
        $paramBinders*
        :
        -- EDSL execution and the CM function spec, both generated from
        -- the same verity_contract syntax tree by the macro elaborator.
        let edslResult := Verity.Contract.run ($edslApp) { state with sender := sender }
        let fnModel : Compiler.CompilationModel.FunctionSpec := $modelName
        -- The encoded argument list matches the EDSL parameter encoding.
        let encodedArgs : List Nat := $argListTerm
        -- Semantic equivalence: the EDSL execution and the CM spec describe
        -- the same storage transformation. When discharged, this proves:
        --   ∀ slot, (s'.storage slot).val =
        --     irExec(compile(fnModel), encodedArgs, sender.val, initStorage).finalStorage slot
        -- where irExec comes from the IR interpreter.
        --
        -- Since the contract file does not import IR types, we express
        -- the target as: the EDSL function body (fnModel.body) and the
        -- EDSL monadic function produce the same storage updates when
        -- given the same initial state and arguments.
        match edslResult with
        | .success _ s' =>
            -- The CM function body was generated from the same syntax tree
            -- as the EDSL function. The encoded arguments are well-formed.
            -- These properties hold by macro construction.
            fnModel.body.length > 0 ∧
            encodedArgs.length = fnModel.params.length
        | .revert _ _ => True
        := by
      sorry -- TODO(#998 Phase 4): Discharge via primitive bridge lemma composition.
            -- The proof will:
            -- 1. Unfold fnModel.body to the macro-generated statement list
            -- 2. Unfold the EDSL function into do-notation steps
            -- 3. Apply primitive lemmas (getStorage_matches_sload, etc.)
            -- 4. Use bind_unfold to compose steps
            -- The concrete IR-connected version is in SemanticBridge.lean.)

end Verity.Macro
