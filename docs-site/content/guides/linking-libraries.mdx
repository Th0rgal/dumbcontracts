---
title: Linking External Libraries
description: How to use external Yul libraries (Poseidon, Groth16, etc.) with verified contracts
---

# Linking External Libraries

**Time Required**: 30 minutes
**Prerequisites**: Verity project builds (`lake build` passes)

Use the Linker to inject production cryptographic libraries (or any Yul functions) into your verified contracts. You prove properties against simple placeholders in Lean, then swap in real implementations at compile time.

---

## When to Use This

- You need **cryptographic primitives** (Poseidon hash, Groth16 verification, etc.) that are impractical to implement in Lean
- You want to **reuse audited Yul libraries** without re-implementing them
- You want to **prove contract logic** independently of complex library internals

## Quick Start

### 1. Write your library as a `.yul` file

Create a file with plain Yul function definitions (no `object` wrapper):

```yul
// libs/MyHash.yul
function myHash(a, b) -> result {
    // Your implementation here
    result := add(xor(a, b), 0x42)
}
```

### 2. Write a placeholder in your Lean contract

In your EDSL contract, define a placeholder that models the same interface:

```lean
-- Placeholder for proofs: models the hash as addition
-- At compile time, replaced by the real myHash from MyHash.yul
def myHash (a b : Uint256) : Contract Uint256 := do
  return add a b
```

### 3. Add the external call to your ContractSpec

In `Compiler/Specs.lean`, use `Expr.externalCall` to reference the library function:

```lean
-- Inside your contract spec's function body:
Stmt.letVar "h" (Expr.externalCall "myHash" [Expr.param 0, Expr.param 1])
```

The compiler generates a Yul `myHash(arg0, arg1)` call that will be resolved by the linked library.

### 4. Compile with `--link`

```bash
lake exe verity-compiler --link libs/MyHash.yul -o compiler/yul
```

The compiler validates that:
- No duplicate function names across libraries
- Library functions don't shadow generated code or Yul builtins
- All external calls in contracts are satisfied by linked libraries

If validation fails, you get a clear error message:

```
Unresolved external references: myHash
```

This means you forgot to pass `--link libs/MyHash.yul`.

---

## Complete Example: CryptoHash Contract

Verity includes a working example in [`Verity/Examples/CryptoHash.lean`](https://github.com/Th0rgal/verity/blob/main/Verity/Examples/CryptoHash.lean) with libraries in [`examples/external-libs/`](https://github.com/Th0rgal/verity/tree/main/examples/external-libs).

**EDSL placeholder** (`Verity/Examples/CryptoHash.lean`):
```lean
-- Placeholder: just adds the inputs (for proving logic)
def hashTwo (a b : Uint256) : Contract Uint256 := do
  return add a b

def storeHashTwo (a b : Uint256) : Contract Unit := do
  let h <- hashTwo a b
  setStorage lastHash h
```

**External library** (`examples/external-libs/PoseidonT3.yul`):
```yul
function PoseidonT3_hash(a, b) -> result {
    result := add(xor(a, b), 0x1234...)
}
```

**Compile with linking**:
```bash
lake exe verity-compiler \
    --link examples/external-libs/PoseidonT3.yul \
    --link examples/external-libs/PoseidonT4.yul \
    -o compiler/yul
```

---

## How the Linker Works

The linking process has three stages:

### Stage 1: Parse libraries

The linker reads each `.yul` file and extracts function definitions using a line-based parser. It tracks brace depth to capture complete function bodies:

```
Input file:           Parsed output:
function foo() {  ->  LibraryFunction { name: "foo", body: [...] }
    sstore(0, 1)
}
```

### Stage 2: Validate

Three safety checks run before any code is injected:

| Check | What it catches |
|-------|-----------------|
| `validateNoDuplicateNames` | Two libraries defining the same function |
| `validateNoNameCollisions` | Library function shadowing `mappingSlot` or Yul builtins like `add`, `sstore` |
| `validateExternalReferences` | Contract calling a function not provided by any library |

### Stage 3: Inject

Library functions are injected into the runtime `code {}` section of each compiled Yul contract, with proper indentation:

```yul
object "MyContract" {
    code { /* deploy */ }
    object "runtime" {
        code {
            // ... generated contract code ...

            // Injected from MyHash.yul:
            function myHash(a, b) -> result {
                result := add(xor(a, b), 0x42)
            }
        }
    }
}
```

---

## Library File Format

External library files must contain **plain Yul function definitions**:

```yul
// Good: plain function definitions
function foo(x) -> y {
    y := add(x, 1)
}

function bar(a, b) -> c {
    c := mul(a, b)
}
```

Do **not** wrap them in an `object` block:

```yul
// Bad: object wrapper not supported
object "MyLib" {
    code {
        function foo(x) -> y { y := add(x, 1) }
    }
}
```

---

## Converting Solidity to Yul

If you have an existing Solidity library you want to use with Verity, you need to convert it to pure Yul. Here's how:

### Step 1: Extract the Logic

Take the Solidity function and identify:
1. Input parameters
2. Output values
3. Internal computations

**Solidity example**:
```solidity
function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "overflow");
    return c;
}
```

**Yul equivalent**:
```yul
function safeAdd(a, b) -> result {
    result := add(a, b)
    // Note: overflow check must be done by caller
    // Yul's add() wraps like EVM
}
```

### Step 2: Handle Special Cases

| Solidity Feature | Yul Approach |
|-----------------|--------------|
| `require(cond, msg)` | `if iszero(cond) { revert(0, 0) }` |
| `return x` | `result := x` (assign to output var) |
| `mapping` | Use `sload(keccak256(...))` / `sstore(...)` |
| `memory` arrays | Use `mload` / `mstore` with offsets |
| `abi.encode` | Manual packing with `shl` / `or` |

### Step 3: Convert Common Patterns

**Conditional logic**:
```solidity
// Solidity
if (a > b) { return a; } else { return b; }
```
```yul
// Yul
function max(a, b) -> result {
    switch gt(a, b)
    case 1 { result := a }
    default { result := b }
}
```

**Loops** (use with caution - gas limits):
```solidity
// Solidity
for (uint i = 0; i < n; i++) { ... }
```
```yul
// Yul
function loopExample(n) -> result {
    for { let i := 0 } lt(i, n) { i := add(i, 1) } {
        // body
    }
}
```

### Complete Example: Math Library

**Solidity** (`MathUtils.sol`):
```solidity
library MathUtils {
    function sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
}
```

**Yul** (`MathUtils.yul`):
```yul
// Newton-Raphson integer square root
function sqrt(x) -> result {
    if iszero(x) {
        result := 0
        leave
    }
    // Initial estimate
    result := div(add(x, 1), 2)
    let y := x
    // Iterate until convergence
    for {} lt(result, y) {} {
        y := result
        result := div(add(div(x, result), result), 2)
    }
}
```

**Link it**:
```bash
lake exe verity-compiler --link libs/MathUtils.yul -o compiler/yul
```

### Using solc to Generate Yul

For complex Solidity libraries, you can use `solc --ir` to generate Yul:

```bash
solc --ir MathUtils.sol
```

This outputs Yul (in an `object` wrapper). Extract the `function` definitions from the `code` block and place them in a plain `.yul` file.

**Caveats**:
- Generated Yul may include EVM version-specific opcodes
- External calls and storage access patterns differ
- You may need to simplify generated code

---

## Trust Model

External libraries are **outside the formal verification boundary**. The Linker validates structural properties (no shadowing, all references resolved) but does not verify the library's correctness.

Your proofs establish: *"If the library functions behave like the placeholders, then the contract is correct."*

### Security Considerations

| Risk | Mitigation |
|------|------------|
| Library contains bugs | Use audited implementations |
| Library has malicious code | Review library source before linking |
| Placeholder â‰  Library behavior | Add end-to-end Foundry tests with linked contract |
| Library modifies unexpected storage | Audit storage slot usage |

### Limitations

1. **No differential testing**: The `SpecInterpreter` returns 0 for external calls, so linked library behavior isn't validated in property tests (see [issue #172](https://github.com/Th0rgal/verity/issues/172))

2. **Text-level injection**: Libraries are injected as raw text, not merged at the AST level. This means:
   - No syntax validation of library code
   - Formal proofs don't cover the linked code
   - Malformed Yul could break compilation

3. **No signature checking**: The Linker validates names exist but doesn't verify function signatures match

### Best Practices

1. **Use trusted libraries**: Prefer audited cryptographic libraries (e.g., from OpenZeppelin, Aztec)

2. **Add end-to-end tests**: Create Foundry tests that compile with linked libraries and test real behavior:
   ```bash
   # Compile with linking
   lake exe verity-compiler --link libs/Poseidon.yul -o compiler/yul
   
   # Test the actual compiled bytecode
   FOUNDRY_PROFILE=difftest forge test --match-contract MyLinkedContract
   ```

3. **Document trust assumptions**: If using linked libraries, note this in your contract's documentation

4. **Audit library code**: Read and understand any library code you link

To increase confidence in linked libraries:
- Use audited, battle-tested implementations
- Add Foundry fuzz tests that exercise the linked contract end-to-end
- Document the trust assumption explicitly (see [`TRUST_ASSUMPTIONS.md`](https://github.com/Th0rgal/verity/blob/main/TRUST_ASSUMPTIONS.md))

---

## CLI Reference

```bash
lake exe verity-compiler [options]

Options:
  --link <path>      Link external Yul library (can be used multiple times)
  --output <dir>     Output directory (default: compiler/yul)
  -o <dir>           Short form of --output
  --verbose          Enable verbose output
  -v                 Short form of --verbose
  --help             Show help message
```

**Examples**:
```bash
# Compile without libraries
lake exe verity-compiler

# Compile with one library
lake exe verity-compiler --link libs/Poseidon.yul

# Compile with multiple libraries, verbose output
lake exe verity-compiler \
    --link libs/PoseidonT3.yul \
    --link libs/PoseidonT4.yul \
    --link libs/Groth16.yul \
    -v -o output/
```
