# Dumb Contracts

> **For AI agents:** This file provides a complete overview. Add `.md` to any docs page URL to get raw markdown.

## Project Overview

Lean 4 EDSL for smart contracts with machine-checked proofs. Zero sorry, zero axioms.

**Core**: Models contract state, storage operations, and `require` guards using explicit success/revert result type (`ContractResult`).

**Contracts**: 7 examples with full formal verification covering correctness, conservation laws, and storage isolation.

## Quick Facts

- **Language**: Lean 4.15.0
- **Core Size**: Small (few hundred lines)
- **Contracts**: SimpleStorage, Counter, Owned, SimpleToken, OwnedCounter, Ledger, SafeCounter
- **Theorems**: Fully proven (no sorry, no axioms)
- **Build**: `lake build` verifies all proofs
- **Repository**: https://github.com/Th0rgal/dumbcontracts

## Key Design

```lean
-- Contracts are functions: ContractState -> ContractResult
inductive ContractResult (α : Type) where
  | success : α → ContractState → ContractResult α
  | revert : String → ContractState → ContractResult α

-- Custom bind short-circuits on revert
def bind (x : Contract α) (f : α → Contract β) : Contract β :=
  fun s => match x.run s with
    | ContractResult.success a s' => (f a).run s'
    | ContractResult.revert msg s' => ContractResult.revert msg s'
```

## Theorem Breakdown

| Contract | Key Properties |
|----------|----------------|
| SimpleStorage | Store/retrieve roundtrip, state isolation |
| Counter | Arithmetic, composition, decrement-at-zero |
| Owned | Access control, ownership transfer |
| SimpleToken | Mint/transfer, supply conservation, storage isolation |
| OwnedCounter | Cross-pattern composition, lockout proofs |
| Ledger | Deposit/withdraw/transfer, balance conservation |
| SafeCounter | Overflow/underflow revert proofs |
| Stdlib/Math | safeMul/safeDiv correctness |

## Proof Techniques

**Full unfolding**: Unfold entire operation chain with `simp only`, then apply guard conditions.

**Private helpers**: Pre-compute exact result states when guards pass.

**Conservation**: Use `List.countOcc` to account for duplicate addresses in exact sum equations.

**No Mathlib**: Manual `Nat.*` lemma chains replace `omega`, `ring`, `linarith`.

## Documentation URLs

- Main: https://dumbcontracts.thomasm.ar/
- Verification: https://dumbcontracts.thomasm.ar/verification
- Research: https://dumbcontracts.thomasm.ar/research
- Examples: https://dumbcontracts.thomasm.ar/examples
- Core: https://dumbcontracts.thomasm.ar/core

Add `.md` to any URL for raw markdown (saves tokens).

## Known Limitations

- Self-transfer requires `sender != to` (implementation ordering)
- Supply = sum(balances) requires finite address model
- No events, no gas modeling
- No nested mappings (can't express ERC-20 allowances)

## What's Next

1. Self-transfer handling
2. Finite address set for full supply = sum(balances)
3. ERC-20 allowances (nested mapping support)
4. Gas consumption tracking
5. Cross-contract call modeling
