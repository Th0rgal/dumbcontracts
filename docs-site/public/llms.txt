# Verity

> **For AI agents:** This file provides a complete overview. Add `.md` to any docs page URL to get raw markdown.

## Project Overview

Lean 4 EDSL for writing smart contracts with machine-checked proofs. Three-layer verified compilation pipeline: EDSL -> CompilationModel -> IR -> Yul -> EVM bytecode.

**Core**: Models contract state, storage operations, and `require` guards using explicit success/revert result type (`ContractResult`).

**Contracts**: 9 formally verified contracts (+ CryptoHash as unverified linker demo) covering correctness, conservation laws, and storage isolation.

**Compiler**: Declarative `CompilationModel` DSL compiles to Yul with verified IR generation. Solidity-compatible function selectors via keccak256.

## Quick Facts

- **Language**: Lean 4.15.0
- **Core Size**: 376 lines
- **Verified Contracts**: SimpleStorage, Counter, Owned, SimpleToken, OwnedCounter, Ledger, SafeCounter, ReentrancyExample (+ CryptoHash as unverified linker demo)
- **Theorems**: 431 across 11 categories (431 fully proven, 0 `sorry` placeholders)
- **Axioms**: 1 documented axiom (see AXIOMS.md) — keccak256_first_4_bytes only
- **Tests**: 416 Foundry tests, multi-seed differential testing (7 seeds), 8-shard parallel CI
- **Build**: `lake build` verifies all proofs
- **Repository**: https://github.com/Th0rgal/verity

## Architecture

```
Layer 1: EDSL Proofs      — Lean theorems about contract behavior
Layer 2: Compiler Proofs  — CompilationModel -> IR preservation
Layer 3: IR -> Yul        — Statement/expression equivalence proofs
Trust:   Yul -> Bytecode  — Via solc (validated by differential testing)
```

## Key Design

```lean
-- Contracts are functions: ContractState -> ContractResult
inductive ContractResult (α : Type) where
  | success : α → ContractState → ContractResult α
  | revert : String → ContractState → ContractResult α

-- Custom bind short-circuits on revert
def bind (x : Contract α) (f : α → Contract β) : Contract β :=
  fun s => match x.run s with
    | ContractResult.success a s' => (f a).run s'
    | ContractResult.revert msg s' => ContractResult.revert msg s'
```

## Theorem Breakdown

| Contract | Count | Key Properties |
|----------|-------|----------------|
| SimpleStorage | 20 | Store/retrieve roundtrip, state isolation |
| Counter | 28 | Arithmetic, composition, decrement-at-zero |
| Owned | 23 | Access control, ownership transfer |
| SimpleToken | 61 | Mint/transfer, supply conservation, storage isolation |
| ERC20 | 19 | Foundation scaffold with initial spec/read-state proofs |
| ERC721 | 11 | Foundation scaffold with ownership/approval read-state proofs |
| OwnedCounter | 48 | Cross-pattern composition, lockout proofs |
| Ledger | 33 | Deposit/withdraw/transfer, balance conservation |
| SafeCounter | 25 | Overflow/underflow revert proofs |
| ReentrancyExample | 4 | Reentrancy vulnerability proof, supply invariant |
| Stdlib | 159 | safeMul/safeDiv correctness, automation lemmas |

## Proof Techniques

**Full unfolding**: Unfold entire operation chain with `simp only`, then apply guard conditions.

**Private helpers**: Pre-compute exact result states when guards pass.

**Conservation**: Use `List.countOcc` to account for duplicate addresses in exact sum equations.

**No Mathlib**: Manual `Nat.*` lemma chains replace `omega`, `ring`, `linarith`.

## CI Validation

The GitHub Actions workflow validates:
- All Lean proofs compile (`lake build`)
- No `sorry` in any proof files (all proofs complete)
- All axioms documented in AXIOMS.md
- Property manifest in sync with Lean proofs
- All manifest theorems have tests (or documented exclusions)
- Storage layout consistency across EDSL/Spec/Compiler layers
- Selector hashes match specs
- Generated Yul compiles with solc (including CryptoHash with linked libraries)
- Contract file structure and All.lean import validation
- Foundry tests pass (8 shards, 7 seeds)

## External Library Linking

Use the Linker to inject production Yul libraries (Poseidon, Groth16, etc.) into compiled contracts. Prove properties against simple placeholders in Lean, then swap in real implementations at compile time.

**Workflow**: EDSL placeholder (addition) → CompilationModel with `Expr.externalCall` → `--link lib.yul` at compile time → Yul with injected library functions.

**Example**: CryptoHash contract demonstrates the full pattern:
- EDSL: `Verity/Examples/CryptoHash.lean` (placeholder: `add a b`)
- Spec: `Compiler/Specs.lean` → `cryptoHashSpec` (calls `PoseidonT3_hash`)
- Library: `examples/external-libs/PoseidonT3.yul`
- Compile: `lake exe verity-compiler --link examples/external-libs/PoseidonT3.yul --link examples/external-libs/PoseidonT4.yul`

**Validation**: The Linker checks for duplicate names, builtin shadowing, unresolved external references, and call-site arity mismatches before injecting.

**Trust model**: Linked libraries are outside the proof boundary. Proofs establish: "If the library behaves like the placeholder, the contract is correct."

## Documentation URLs

- Main: https://verity.thomas.md/
- Verification: https://verity.thomas.md/verification
- Research: https://verity.thomas.md/research
- Examples: https://verity.thomas.md/examples
- Core: https://verity.thomas.md/core
- Compiler: https://verity.thomas.md/compiler
- Guides (First Contract): https://verity.thomas.md/guides/first-contract
- Guides (Linking Libraries): https://verity.thomas.md/guides/linking-libraries
- Guides (Debugging Proofs): https://verity.thomas.md/guides/debugging-proofs
- Add a Contract: https://verity.thomas.md/add-contract

Add `.md` to any URL for raw markdown (saves tokens).

## Trust Assumptions

See TRUST_ASSUMPTIONS.md for full analysis. Key trust boundaries:
- **Verified**: EDSL -> CompilationModel -> IR -> Yul
- **Trusted**: Yul -> Bytecode (via solc, validated by 70k+ differential tests)
- **Axioms**: 1 documented, with soundness justification
- **External**: Lean 4 kernel, EVM specification alignment

## Known Limitations

- All proofs complete — Ledger sum properties proven in Conservation.lean (issue #65 resolved)
- No gas modeling
- Self-transfer handled via delta-zero pattern (not separate logic)

## DSL Capabilities (CompilationModel)

The CompilationModel DSL supports: if/else branching (`Stmt.ite`), bounded loops (`Stmt.forEach`), event emission (`Stmt.emit`), nested/double mappings (`Expr.mapping2`, `Stmt.setMapping2`), uint256-keyed mappings (`Expr.mappingUint`, `Stmt.setMappingUint`), internal function composition (`Stmt.internalCall`, `Expr.internalCall`), dynamic array/bytes parameters, and external library linking (`Expr.externalCall`).

## What's Next

1. EVMYulLean integration: upgrade Lean, replace Yul semantics (#294)
2. ERC-20 standard token (#69)
3. Address soundness: replace String with ByteArray (#253)
