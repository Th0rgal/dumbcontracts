#!/usr/bin/env python3
"""Generate PrintAxioms.lean from all top-level theorems in Verity/Proofs/ and Compiler/Proofs/.

This script scans Lean proof files for top-level theorem/lemma declarations,
resolves their fully-qualified names (accounting for namespace blocks), and
generates a Lean file that runs `#print axioms` on each public theorem.

Usage:
    python3 scripts/generate_print_axioms.py          # overwrite PrintAxioms.lean
    python3 scripts/generate_print_axioms.py --check   # verify PrintAxioms.lean is up-to-date
"""

import re
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
PROOF_DIRS = [ROOT / "Verity" / "Proofs", ROOT / "Compiler" / "Proofs"]
OUTPUT = ROOT / "PrintAxioms.lean"


def file_to_module(path: Path) -> str:
    """Convert a file path to a Lean module name."""
    rel = path.relative_to(ROOT).with_suffix("")
    return ".".join(rel.parts)


def extract_theorems(path: Path) -> list[tuple[str, bool]]:
    """Extract (fully_qualified_name, is_private) pairs from a Lean file."""
    text = path.read_text()
    module = file_to_module(path)
    lines = text.splitlines()

    # Track namespace stack
    ns_stack: list[str] = []
    in_block_comment = False
    results: list[tuple[str, bool]] = []

    for line in lines:
        stripped = line.strip()

        # Handle block comments
        if "/-" in stripped and "-/" not in stripped:
            in_block_comment = True
            continue
        if in_block_comment:
            if "-/" in stripped:
                in_block_comment = False
            continue

        # Skip line comments
        if stripped.startswith("--"):
            continue

        # Track namespace
        ns_match = re.match(r"^namespace\s+(\S+)", stripped)
        if ns_match:
            ns_stack.append(ns_match.group(1))
            continue
        if re.match(r"^end\s+", stripped):
            if ns_stack:
                ns_stack.pop()
            continue

        # Match theorem/lemma declarations
        decl_match = re.match(
            r"^(private\s+)?(protected\s+)?(theorem|lemma)\s+(\S+)", stripped
        )
        if decl_match:
            is_private = decl_match.group(1) is not None
            name = decl_match.group(4)
            # Remove trailing colon/where if present
            name = name.rstrip(":")

            if ns_stack:
                fqn = f"{module}.{'.'.join(ns_stack)}.{name}"
            else:
                fqn = f"{module}.{name}"

            results.append((fqn, is_private))

    return results


def generate() -> str:
    """Generate the full PrintAxioms.lean content."""
    all_files: list[Path] = []
    for d in PROOF_DIRS:
        if d.exists():
            all_files.extend(sorted(d.rglob("*.lean")))

    # Skip SpecInterpreter since it doesn't contain proofs directly used
    all_files = [f for f in all_files if "README" not in f.name]

    imports: list[str] = []
    sections: list[str] = []

    for path in all_files:
        theorems = extract_theorems(path)
        if not theorems:
            continue

        module = file_to_module(path)
        imports.append(f"import {module}")

        rel = path.relative_to(ROOT)
        lines = [f"\n-- {rel}"]
        for fqn, is_private in theorems:
            if is_private:
                lines.append(f"-- #print axioms {fqn}  -- private")
            else:
                lines.append(f"#print axioms {fqn}")

        sections.append("\n".join(lines))

    public_count = sum(
        1
        for path in all_files
        for _, priv in extract_theorems(path)
        if not priv
    )
    private_count = sum(
        1
        for path in all_files
        for _, priv in extract_theorems(path)
        if priv
    )

    header = (
        "-- Auto-generated by scripts/generate_print_axioms.py\n"
        "-- Runs #print axioms on all top-level theorems/lemmas in proof directories.\n"
        "-- Regenerate with: python3 scripts/generate_print_axioms.py\n"
    )

    footer = (
        f"\n-- Total: {public_count + private_count} theorems/lemmas"
        f" ({public_count} public, {private_count} private)\n"
    )

    return header + "\n" + "\n".join(imports) + "\n" + "\n".join(sections) + footer


def main() -> None:
    content = generate()

    if "--check" in sys.argv:
        if not OUTPUT.exists():
            print(f"ERROR: {OUTPUT} does not exist. Run without --check to generate.")
            sys.exit(1)
        existing = OUTPUT.read_text()
        if existing != content:
            print(f"ERROR: {OUTPUT} is out of date. Regenerate with:")
            print(f"  python3 scripts/generate_print_axioms.py")
            sys.exit(1)
        print(f"OK: {OUTPUT} is up to date.")
    else:
        OUTPUT.write_text(content)
        print(f"Generated {OUTPUT} with {content.count('#print axioms')} #print axioms statements.")


if __name__ == "__main__":
    main()
